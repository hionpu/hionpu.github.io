[
  
  {
    "title": "Liquid curly bracket 그대로 표시하기",
    "url": "/posts/liquid_curly_bracket",
    "categories": "html",
    "tags": "#html, #liquid, #escape, #curlybracket",
    "date": "2023-12-11 00:00:00 +0900",
    





    
    "snippet": "1. html 문법에서  &#38;#123; 와&#38;#125;를 사용하는 것이 가장 편한것 같다. 문제는 코드 블럭 안에 {{ something }} 를 넣어야 할 때이다.2. .md파일이 html로 변경될 상황에서 코드블럭 내부의 이중 curly bracket를 사용하면 된다.",
    "content": "1. html 문법에서  &#38;#123; 와&#38;#125;를 사용하는 것이 가장 편한것 같다. 문제는 코드 블럭 안에 {{ something }} 를 넣어야 할 때이다.2. .md파일이 html로 변경될 상황에서 코드블럭 내부의 이중 curly bracket를 사용하면 된다."
  },
  
  {
    "title": "GitHub 블로그 개설하기(3) - 포스팅",
    "url": "/posts/github_blog_3",
    "categories": "[GitHub, jekyll]",
    "tags": "#github, blog, chirpy",
    "date": "2023-12-11 00:00:00 +0900",
    





    
    "snippet": "시리즈 포스트 링크(1) Repository 생성과 테스트 페이지 확인하기(2) Chirpy 테마 적용(3) 포스팅(4) 다국어 지원하기(5) 사이트맵 생성하기1. 포스트 파일명 형식과 저장 위치포스팅할 글은  2023-12-11-글제목.md형식으로 마크다운 파일이어야 하고 .md 파일들을 _post 폴더에 넣어주면 된다.Jekyll이 빌드될 때 블로...",
    "content": "시리즈 포스트 링크(1) Repository 생성과 테스트 페이지 확인하기(2) Chirpy 테마 적용(3) 포스팅(4) 다국어 지원하기(5) 사이트맵 생성하기1. 포스트 파일명 형식과 저장 위치포스팅할 글은  2023-12-11-글제목.md형식으로 마크다운 파일이어야 하고 .md 파일들을 _post 폴더에 넣어주면 된다.Jekyll이 빌드될 때 블로그 루트 폴더/_posts 에 저장된 .md 파일을 모두 찾아서(_posts 내부에 폴더가 있으면 그 폴더도 탐색함) .html 파일로 컴파일하고 _site 폴더에 넣는다. _site 폴더에 들어있는 .html 파일들이 실제로 배포했을 때(또는 localhost:4000에서) 보이는 페이지들이 된다. 다만 _site 폴더에 파일이름과 하위 상대 경로 변경 없이 그대로 들어가지는 않고 _config.yml의defaults:...\t-scope:\t...\tvalues:\t\tlayout: page\t\tpermalink: /:title/...에서 permalink: 속성을 참조해서 들어가는데, 이 속성은 전역 설정이고 .md 파일에서 property 하위에 permalink: 경로 를 입력함으로써 수정할 수 있다. 이 부분은 차후에 다국어 지원을 위한 Jekyll의 플러그인 중 하나인 polyglot을 사용할 때 포스트마다 지정해주어야 한다. 현재 단계에서는 일단 그냥 두자.2. 포스트 작성업로드한 포스팅을 클릭해서 글을 읽을 때 오른쪽 패널에 최근 업데이트 글, 태그, 목차가 표시되는데 이 중에 목차는 chipy 테마에서 jekyll이 빌드할 때 자동으로 # 등의 헤더를 뽑아내서 만들어 준다. 나는 이 부분도 약간의 커스터마이징을 위해 tocbot을 사용했지만 나중에 설명하기로 하고 아무튼 헤더를 인식하고 목차를 생성한다는 사실은 알아두자.이보다 중요한 것은 마크다운 파일의 property 부분을 작성하는 것인데 지난 포스팅의 .md 파일의 property를 예로 들어 설명하겠다.---title: Setting Up a GitHub Blog (1) - Creating a Repository and Checking the Test Pagedate: 2023-12-04 15:22lastmod: 2023-12-07 15:56tags:  - \"#github\"  - \"#blog\"  - \"#jekyll\"  - \"#polyglot\"categories:  - \"[GitHub, jekyll]\"lang: enpermalink: /posts/Github_blog_1pin: truemath: truemermaid: true---  title: 블로그에 업로드됐을 때 보여지는 글 제목이다.  date: 글이 생성된 일시 YYYY-MM-DD HH:MM 형식으로 쓴다.  lastmod: 최근 수정 일시. 이 속성이 있어야 sitemap 생성할 때 편하다. 귀찮으면 글 생성일과 동일하게 두자.  tags: 태그. 여러 개를 입력할 수 있고 chirpy 테마는 배포된 페이지의 TAGS 탭에서 태그별로 글을 분류해준다.  categories: 태그와 비슷한데 역시 chirpy에서 카테고리별 분류를 해준다. 폴더랑 비슷한 성격인듯  lang: 다국어 지원을 하려면 필요하다. _config.yml의 language 속성에 array로 들어간 언어 속성을 loop로 돌면서 각 언어별 페이지를 생성하기 때문이다.  permalink: _config.yml에서 설정한 전역 permalink 속성을 덮어쓰는 속성이다.  pin:, math:, mermaid: 각각 부가적인 기능을 제공하는데 chirpy테마에 예시로 딸려온 포스트들에 모두 true로 돼있다.이제 아래 템플릿을 복붙해서 각 속성을 채우자. 나는 마크다운 에디터로 Obsidian을 사용하는데 {{date}}와 {{time}}을 입력하고 템플릿으로 사용하면 글 생성 당시의 시간으로 타임스탬프처럼 입력된다.---title: tags: categories: createdAt: {{ date }} {{ time }}lastmod:  {{ date }} {{ time }}lang: kopermalink: /posts/pin: truemath: truemermaid: true---3. 저장, 푸시, 빌드, 배포위에서 말한 대로 .md파일을 로컬의 루트폴더/_posts 안에 넣고 먼저 로컬에서만 빌드하고 확인해보자.bundle exec jekyll servelocalhost:4000으로 이동해서 확인하고 포스팅이 올바르게 표시되면 푸시하고 자동으로 빌드, 배포된 페이지를 확인해보자.이어지는 글(4) 다국어 지원하기"
  },
  
  {
    "title": "GitHub 블로그 개설하기(2) - Chirpy 테마 적용",
    "url": "/posts/github_blog_2",
    "categories": "[GitHub, jekyll]",
    "tags": "#github, #blog, #chirpy",
    "date": "2023-12-07 16:04:00 +0900",
    





    
    "snippet": "시리즈 포스트 링크(1) Repository 생성과 테스트 페이지 확인하기(2) Chirpy 테마 적용 (3) 포스트 올리기(4) 다국어 지원하기(5) 사이트맵 생성하기1. Chirpy 테마 파일 다운로드테마를 모아놓은 사이트에서 zip 파일을 제공하기도 하고, chipy 공식 repository에서 fork 해오는 방법도 있지만 나는 fork 말고 ...",
    "content": "시리즈 포스트 링크(1) Repository 생성과 테스트 페이지 확인하기(2) Chirpy 테마 적용 (3) 포스트 올리기(4) 다국어 지원하기(5) 사이트맵 생성하기1. Chirpy 테마 파일 다운로드테마를 모아놓은 사이트에서 zip 파일을 제공하기도 하고, chipy 공식 repository에서 fork 해오는 방법도 있지만 나는 fork 말고 clone 했다.  Chirpy Repository클론한 위치에 jekyll-theme-chirpy라는 폴더가 있는데 내용물을 전부 복사해서 내 로컬 repository에 복사한다(…/(git 계정명).github.io). 덮어쓰시겠습니까 $\\implies$ 예2. Ruby와 Jekyll 설치Ruby  Ruby installer 다운로드 링크맨위에 굵은글씨로 다운받고 실행한 다음 next연타하면 설치 끝나고이게 뜨면 3 엔터 해주면 끝.Jekyll그러면 시작(윈도우 키)메뉴에 Start Command Prompt with Ruby가 생겨있다. 실행하고 내 깃허브 블로그 로컬 repository(앞으로 따로 설명이 없으면 내 깃 블로그의 로컬 repository 폴더에서 입력한다)에서gem install jekyllgem install bundler를 입력해서 jekyll과 bundler도 설치하자. 그리고 혹시 모르니ruby -vjekyll -vbundler -v으로 설치가 잘 됐는지 확인이렇게 나오면 된것(설치 시점에 따라 버전이 다를 수 있다).3. Node.js 설치와 npm  Node.Js 다운로드다운받아 설치하고 다시 Command Prompt에서npm install &amp;&amp; npm run build해줘야 jekyll로 빌드할 때 *.min.js 가 없다고 찡찡거리지 않는다.4. Chirpy 테마 설치로컬 블로그 폴더에서 doc 폴더를 삭제한다. _posts 폴더의 내용물은 삭제해도 되지만 로컬이나 깃허브 배포 후에 정상작동 여부를 확인하기 위해 그냥 두어도 된다.그리고 로컬 블로그 폴더/.github/workflows 안에 pages-deploy.yml.hook 이라는 파일만 제외하고 전부 삭제하고 이 파일의 맨 뒤에 .hook 확장자를 삭제해서 .yml 파일로 만든다.이제bundle하면 테마가 설치된다.5. 로컬에서 확인하기bundle exec jekyll serve --liveReload입력하고 아무 브라우저에서 주소창에 localhost:4000을 입력하면 실제로 배포됐을 때의 블로그 화면을 볼 수 있다. --liveReload는 페이지를 구성하는 파일들이 변경되면 즉시 블로그 화면에 반영해주는 옵션이다.6. GitHub Action 설정블로그가 잘 표시된다면 깃허브에 올리면 되는데, Chirpy 테마는 GitHub Action으로 자동 빌드, 배포하지 않으면 오류가 난다. 따라서 먼저 Action을 설정하러 가자.![[Pasted image 20231208143014.png]]내 블로그의 GitHub repository의 Settings - 좌측 탭 중간아래에 Pages로 가면 Source 밑에 Deploy from a branch를 눌러보면Deploy from a branch에 체크되어 있는 것을 GitHub Actions를 눌러 변경한다.밑에 생긴 박스에서 Configure를 누르고다른거 건들 필요 없이 우측 상단에 Commit changes… 클릭하면 배포 준비 끝7. _config.yml 수정 및 리모트 빌드 준비pull 받기먼저 리모트에서 파일을 수정했으므로(Action을 추가함, .github/workflow 내부에서 수정이 이루어짐)git pull버전을 업데이트 한다.*.min.js gitignore 수정로컬 루트 폴더에서 .gitignore를 수정해야 하는데맨 아래# Miscassets/js/dist부분에서 assets… 앞에 #을 붙여서 주석 처리한다.# Misc# assets/js/dist그래야 npm으로 생성한 *.min.js 파일들이 정상적으로 푸시될 수 있다._config.yml 수정루트 폴더 내 _config.yml 파일을 열어서url: \"\"”” 안에 \\https://username.github.io 본인의 깃허브 주소를 적는다. 나는 hionpu.com 도메인을 사용하고 있어서url: \"hionpu.com\"을 적었다. 추가적으로languages: ['ko', 'en']...default_lang: 'ko'...timezone: Asia/Seoul...title: 블로그 이름tagline: 블로그 이름 밑에 들어갈 문장description: 블로그 설명...github:\tusername: 깃허브계정명...등은 본인에게 맞게 수정해도 좋다. 보통 수정하면 곤란한 부분은 chirpy 원작자가 경고를 해놓았다. 이 _config.yml은 이후에 다른 설정을 할 때도 수정할 부분이 많다.8. 푸시해서 자동 빌드, 배포하기이제 수정한 파일을 푸시한다.git add *git commit -m \"git blog init\"git push origin main그러면 리모트 repository의 Action 탭에서 빌드와 배포가 되는 것을 확인할 수 있다. 초록불이 들어오면 본인의 블로그 주소(username.github.io)에 들어가서 블로그가 온라인에서 보이는지 확인하자.빨간불이 들어오거나 초록불이 들어왔지만 블로그가 정상 작동하지 않는 경우는 추후에 작성할 에러케이스 모음 포스팅을 참고해서 해결할 수 있도록 할 것이다.8. 이어지는 다음 글(3) 포스트 올리기"
  },
  
  {
    "title": " GitHub 블로그 개설하기(1) - Repository 생성과 테스트 페이지 확인하기",
    "url": "/posts/github_blog_1",
    "categories": "[GitHub, jekyll]",
    "tags": "#github, #blog, #jekyll, #polyglot",
    "date": "2023-12-04 15:22:00 +0900",
    





    
    "snippet": "머릿말지난 며칠간 깃허브 페이지 블로그를 만들었다. 티스토리나 구글 블로그스팟으로 하려고 했었는데 다국어 지원을 해내고 싶다는 이상한 생각에 사로잡혀서 깃허브 페이지까지 오게 되었다.티스토리/블로그스팟은 다국어 지원 플러그인이 있긴 하지만 저렴이 버전의 자동번역은 품질이 걱정되고 내가 번역본을 수정하기가 어려워 보여서 버렸다.진행하면서 중간에 오류가 ...",
    "content": "머릿말지난 며칠간 깃허브 페이지 블로그를 만들었다. 티스토리나 구글 블로그스팟으로 하려고 했었는데 다국어 지원을 해내고 싶다는 이상한 생각에 사로잡혀서 깃허브 페이지까지 오게 되었다.티스토리/블로그스팟은 다국어 지원 플러그인이 있긴 하지만 저렴이 버전의 자동번역은 품질이 걱정되고 내가 번역본을 수정하기가 어려워 보여서 버렸다.진행하면서 중간에 오류가 정보도 없고 해결도 안돼서 아 그냥 티스토리 할까 싶은 때가 꽤 있었는데 GPT를 집요하게 괴롭혀서 결국 해냈다. 단계별로 다음과 같이 진행했고 나는 Chirpy 테마를 사용했기 때문에 다른 테마를 사용하는 경우에 도움이 되지 않을 수도 있다.시리즈 포스트 링크(1) Repository 생성과 테스트 페이지 확인하기(2) Chirpy 테마 적용(3) 포스트 올리기(4) 다국어 지원하기(5) 사이트맵 생성하기1. Repository 생성깃허브 Repositories 탭의 오른쪽에 초록색 New 버튼소유자 - 본인 고르고 _.github.io_ 형식으로 입력(나는 이미 만들어서 아래 빨간 메시지로 이미 있다고 뜨는것)Public과 Add a README file 체크하고 아래에 Create Repository 초록버튼 클릭2. 내 로컬에 클론만들어진 Repository에서 오른쪽 초록색 &lt;&gt; Code 버튼 누르면 내 Repository의 Https 주소 확인 가능(주소창에도 있다). 이것을 복사하고 git bash같은 터미널에서 클론할 위치로 이동한 다음git clone 복사한 주소해서 로컬에 클론하면 아까 만든 Repository 이름으로 된 폴더가 생성돼있다. 터미널에서 해당 폴더에 진입하고 임시 테스트용 인덱스 파일을 하나 만들자cd username.github.ioecho \"Hello World\" &gt; index.html3. index.html 푸시하고 확인git add *git commit -m \"Beginning of my git blog\"git push -u origin main이제 https://계정명.github.io 로 들어가면 인덱스에 적은 내용을 볼 수 있다.다음은 테마를 적용해볼 것이다.이어지는 글(2) Chirpy 테마 적용"
  },
  
  {
    "title": "Rhino처럼 방향이 있는 arc 그리기",
    "url": "/posts/directional_angle",
    "categories": "[geometry, arc]",
    "tags": "#rhino, #angle, directedangle, #arc, #geomtery",
    "date": "2023-10-11 00:00:00 +0900",
    





    
    "snippet": "2023/12/12 변경점  2023/12/12 기준 리팩토링으로 대부분의 구현 방식을 바꿨다. 순서도는 그대로 사용했다.1. 문제상황세 점 C, P, Q(중심점C 과 두 기준선 CP, CQ)이 주어지고 호를 그려야 하는 경우가 있다.​    그림 1-1, 호 PQ​중심점 C와 첫 번째 기준점 P는 주어져 있다고 가정하고 Q는 마우스 커서로 사용자에 ...",
    "content": "2023/12/12 변경점  2023/12/12 기준 리팩토링으로 대부분의 구현 방식을 바꿨다. 순서도는 그대로 사용했다.1. 문제상황세 점 C, P, Q(중심점C 과 두 기준선 CP, CQ)이 주어지고 호를 그려야 하는 경우가 있다.​    그림 1-1, 호 PQ​중심점 C와 첫 번째 기준점 P는 주어져 있다고 가정하고 Q는 마우스 커서로 사용자에 의해 자유롭게 움직일 수 있다고 가정하자.  라이노에서는 호를 그릴 때 (직접 그리든, Rotate, Revolve 등의 기능에서 필요한 보조선을 그리기 위해서든) 마우스 커서 Q의 CP에 대한 처음 위치에 따라 일단 그쪽에 호를 그리기 시작한다(아래 그림 1-2).​    그림 1-2그 상태에서 C에서 시작해 P를 지나는 반직선을 지나지 않은 채 각도를 늘리는 방향으로 커서를 움직이면 360도에 도달할때까지 그 방향으로 호의 길이가 늘어난다.  만약 각도를 줄이는 방향으로 움직이다가 커서가 반직선 CP를 지나 CP 아래에 놓이게 되면 그때부터 그려지는 호는 CPQ의 예각을 중심각으로 하는 호가 된다.  2. 분석이것을 순서도로 표현하면 다음과 같다.​여기서 해결해야 할 문제는 다음과 같다.  1. 커서가 반직선 CP를 통과(교차)하는 것을 판단할 조건은 무엇인가?  2. 통과한 부분이 직선 전체가 아닌 C에서 시작하는 반직선 CP인 것을 판단할 조건은 무엇인가?  3. 통과한 후에 호를 새롭게 그릴 때 어떻게 호를 뒤집을 것인가?  3. 준비// 아래에서 설명bool isRightRay;int crossSign;​//교차가 일어났을 때 이전에 일어났던 교차가 반직선 $CP$ 위에서 일어났는지 확인해야 한다. 이전에 교차 사건 발생시의 `crossSign`값을 저장할 boolint oldCrossSign;​// 아래에서 설명bool crossOccured;​// 호가 그려질 방향을 정하는 부호값. 호를 그리는 함수에 각도를 음수로 전달하면 해당 값에 2파이를 더해서 그림double angleSign = 1.0;​3-1. 커서가 반직선 CP를 통과하는 것을 판단윈도우에서 화면 좌표계는 왼쪽 위 구석이 원점이고 아래 방향이 $y$ 의 양의 방향, 오른쪽 방향이 $x$ 의 양의 방향이다.마우스 커서 $Q$가 $C$에서 시작해서 $P$를 지나는 반직선을 지나는 경우에만 호가 뒤집혀야 하고 이 경우 이외에는 계속 해당 방향으로 호의 중심각이 커지거나 작아져야 한다.  먼저 $CP$의 직선의 방정식을 \\(y = mx + n\\) 으로 둔다. 이제,      일단 반직선 $CP$ 가 아닌 $C$, $P$ 를 지나는 무한한(그래봤자 화면 크기가 최대 범위) 직선을 마우스가 지날 때(cross)를 탐지한다.        그 지점이 반직선 $CP$ 위에서 일어났는지 판단한다.    3-1-1. 직선을 지났는지 탐지하기     cross product 를 이용할 것이다. $\\overrightarrow{CP} \\times \\overrightarrow{CQ}$ 의 방향은 $Q$ 가 직선 $CP$ 위에 있는지 아래에 있는지에 따라 변하므로 이 방향만 추적하면 마우스 커서가 반직선을 지났는지 탐지할 수 있다. 방향을 확인하는 방법은 $z$ 방향의 단위벡터와 dot product를 해서 알아낼 수 있다.// CQ벡터의 x,y성분을 각각 x,y성분으로 갖고 z성분은 0인 벡터vector3 CF = new Vector3(CQ, 0); // CP벡터의 x,y성분을 각각 x,y성분으로 갖고 z성분은 0인 벡터vector3 CP = new Vector3(CP, 0); //CF와 CP의 외적vector3 cross = CF.cross(CP);//z 방향 단위벡터vector3 zUnit = new Vector3(0,0,1); ​// CF x CP 와 z의 내적에 따라 방향을 1 또는 -1로 정함double crossSign = cross.Dot(z) &gt; 0 ? 1 : -1;// '반직선' CP에서 교차가 일어났다면 truebool crossOccured = false;​3-1-2. 그 교차가 반직선 CP 위에서 일어났는지 판단하기반직선의 유형은 두가지로 나뉘는데 호의 중심 $C$ 가 호 반지름의 시작점 $P$ 의 왼쪽에 있는 경우와 오른쪽에 있는 경우이다. 편의상 반직선을 Ray라 하고 $P$가 $C$보다 오른쪽에 있어 Ray가 오른쪽으로 뻗어나가는 경우를 RightRay라 하자. 그리고 이 직선이 RightRay인지 먼저 판단해서 bool값으로 저장한다.bool isRightRay = C.X &lt;= P.X 위 코드처럼 $C$, $P$ 의 좌/우 판단은 각 점의 $x$ 좌표로만 판단하면 된다.  교차가 이미 일어났다고 가정하면, 커서 $Q$ 가 반직선 $CP$ 를 지나는 경우는 커서의 $x$ 좌표 역시 $C$의 $x$ 좌표보다 크면 된다.3-2. 위 조건 분기에 따른 코드이제 위 조건들에 따라 코드를 작성하면 다음과 같다.if (isRightRay){    if (point.X &gt; C.X)    {        crossOccured = true;        // ----- 설명이 필요한 부분 ----        if (point.Y &gt; m * point.X + n)        {            angleSign = 1.0;        }        else angleSign = -1.0;        // ---------------------------    }    else    {        crossOccured = false;    }}이 코드에서 설명되지 않은 부분은        if (point.Y &gt; m * point.X + n)        {            angleSign = 1.0;        }        else angleSign = -1.0;이 부분인데 이것은 반직선 $CP$ 를 통과한 후에 마우스 커서가 $CP$ 보다 위에 있는지(아래에서 위로 통과) 또는 아래에 있는지(위에서 아래로 통과)에 따라 해당 방향으로($CP$와 $CF$가 이루는 각 중 작은 각을 중심각으로 가지는) 호를 그리도록 angleSign을 정해주는 코드이다.이제 RightRay가 아닌 경우를 처리하면 되는데 이것은 간단하다.else{    if (point.X &lt;= C.X)    {        crossOccured = true;        if (point.Y &gt; m * point.X + n)        {            angleSign = -1.0;        }        else angleSign= 1.0;    }    else    {        crossOccured = false;    }}교차를 감지하는 DetectCross() 함수 전체 코드는 다음과 같다.Vector2D C;Vector2D F;private void DetectCross(System.Windows.Point point){    Vector2 _CF = F.ToVector2() - C.ToVector2();    Vector2 _CP = point.ToVector2D() - C.ToVector2();​    Vector3 CF = new Vector3(_CF, 0);    Vector3 CP = new Vector3(_CP, 0);    Vector3 z = new Vector3(0, 0, 1);    Vector3 cross = Vector3.Cross(CF, CP);​    crossSign = cross.Dot(z) &gt; 0 ? 1 : -1;​    if (oldCrossSign != crossSign)    {        if (isRightRay)        {            if (point.X &gt; C.X)            {                crossOccured = true;                if (point.Y &gt; m * point.X + n)                {                    angleSign = 1.0;                }                else angleSign = -1.0;            }            else            {                crossOccured = false;            }        }        else        {            if (point.X &lt;= C.X)            {                crossOccured = true;                if (point.Y &gt; m * point.X + n)                {                    angleSign = -1.0;                }                else angleSign= 1.0;            }            else            {                crossOccured = false;            }        }    }}​3-3. 마우스 이벤트 핸들러에 적용private void MouseMove(object sender, MouseEventArgs e){    var mousePos = e.GetPosition(screen);    _refPoint = screen.ScreenToWorld(mousePos, _plane);​    if (_refPoint != null)    {        DetectCross(mousePos);        if (crossOccured)        {            crossOccured = false;        }        _angle = GetAngle(_startPoint, _refPoint);        _arc = new Arc(_center, _startPoint, angleSign*_angle, _normal)        oldCrossSign = crossSign;    }}  마우스의 좌표를 화면상에서 가져온다 mousePos  화면상 좌표를 실제 호가 그려질 평면(_plane)으로 투영한다 _refPoint   DetectCross() 함수를 이용해 마우스가 반직선 $CP$를 통과했는지 판단하고, 각 경우에 따라 angleSign을 바꾸거나 그대로 둔다.   GetAngle() 함수를 이용해 $CP$( $P$ = _startPoint)와 $CQ$($Q$ = refPoint, 커서) 의 각도를 구하고 _angle 에 저장한다. 여기서 각도는 일반적인 내적을 이용하지 않기 때문에 $\\pi$ 이상이라도 그 값 그대로 반환한다(아래에 함수 있음).   angleSign * _angle을 호를 만드는 함수의 중심각 파라미터에 넣어준다. 여기서 호를 만드는 함수 Arc()는 중심각을 음수로 입력하면 방향을 반대로 그려준다.    3-4 함수    Point3D _center;private double GetAngle(Point3D a, Point3D b)       {           if (a == b) return 0;​           Vector3 aa = _center.ToVector3() - a.ToVector3();           Vector3 bb = _center.ToVector3() - b.ToVector3();​           Vector3 nn = aa.Cross(bb);​           double d = nn.Dot(normal);​           double angle = aa.Angle(bb);                      if (d &gt;= 0)           {               return angle;           }           else           {               return Math.PI * 2 - angle;           }       }        a, b를 파라미터로 전달하면 _center를 시작점으로, a, b를 각각 끝점으로하는 두 벡터 사이의 각을 구한다. 이때, 두 벡터가 놓인 평면의 normal 과 Vector3 aa, bb 의 외적이 (내적 계산을 통해)방향이 같으면 각을 그대로 반환하고, 방향이 다르면 $2\\pi$에서 뺀 각을 반환함으로써 normal 에 따라 각이 $\\pi$ 보다 크더라도 그 값을 그대로 얻을 수 있다.  "
  }
  
]

